---
title: "blastocyst"
author: "Moi T. Nicholas"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{blastocyst}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This vignette will take you through running PPR. \
The data used here is an Intregrated dataset of multiple blastocyst datsets [Here](http://). \
\
\


# Data Pre-procesing

#### Load neccecary packages
```{r eval=FALSE}
library(Seurat)
library(ggplot2)
library(slingshot)
library(RColorBrewer)
library(GeneSwitches)
library(SingleCellExperiment)
library(devtools)
devtools::load_all()
```

## SEURAT

### Here we use this Reprogramming dataset as the reference 
```{r eval=FALSE}
seu <- readRDS("/mainfs/ddnb/PathPinpointR/package/PathPinpointR/data/blastocyst.rds")
```

#### View the reference UMAP
```{r eval=FALSE}
DimPlot(object = seu, reduction = "umap", group.by = "orig.ident" ,label = T) +
  ggtitle("Reference")
DimPlot(object = seu, reduction = "umap", group.by = "seurat_clusters" ,label = T) +
  ggtitle("Reference")
```

### QC
```{r eval=FALSE}
# 
#seu[["percent.mt"]] <- PercentageFeatureSet(seu, pattern = "MT-")

# Visualize QC metrics as a violin plot
#VlnPlot(seu, features = c("nFeature_RNA", "nCount_RNA", "pctMT"), ncol = 3)


```

### QC
```{r}
#seu <- subset(seu, subset = nFeature_RNA > 2500 & pctMT < 10 & nCount_RNA < 1e+07)

# Visualize QC metrics as a violin plot
#VlnPlot(seu, features = c("nFeature_RNA", "nCount_RNA", "pctMT"), ncol = 3)

```

### We use subsets of the Reprogramming dataset as queries.
```{r eval=FALSE}
Mole21a.seu <- subset(x = seu, subset = orig.ident %in% "Mole21a")
```


### Label transfer & Re-integration
####### *When doing this analysis with your own data you would more than likely need to label transfer with your referenece datatset.*
####### *As we are using subsets of our reference data as "samples" this wont be necessary.*
,

## SingeCellExperiment


### Convert objects to SingleCellExperiment objects
```{r eval=FALSE}
sce    <- SingleCellExperiment(assays = list(expdata = seu@assays$RNA$counts))
colData(sce) <- DataFrame(seu@meta.data)
reducedDims(sce)$UMAP <- seu@reductions$umap@cell.embeddings
Mole21a.sce   <- SingleCellExperiment(assays = list(expdata = Mole21a.seu@assays$RNA$counts))
```


## Slingshot

### Run slingshot on the reference data to produce a reprogramming trajectory.
```{r eval=FALSE}
sce  <- slingshot(sce,
                            clusterLabels = "seurat_clusters",
                            start.clus  = "2",
                            end.clus = "1",
                            reducedDim = "UMAP")

#Rename the Pseudotime column to work with GeneSwitches
colData(sce)$Pseudotime <- sce$slingPseudotime_1
```

### Plot the slingshot trajectory.
```{r eval=FALSE}
colors <- colorRampPalette(brewer.pal(11,'Spectral')[-6])(100)
plotcol <- colors[cut(sce$slingPseudotime_1, breaks=100)]
plot(reducedDims(sce)$UMAP, col = plotcol, pch=16, asp = 1)
lines(SlingshotDataSet(sce), lwd=2, col='black')
```


## GeneSwitches
###  Choose a Binerization cutoff
###### **this would be good to automate, 
###### or learn how to use the other method of binarizing
```{r eval=FALSE}
# hist(as.matrix(assays(sce)$expdata),
#            breaks = 1e6)
#  hist(as.matrix(seu@assays$RNA$counts), breaks = 1e6)
#  
#  hist(as.matrix(assays(sce)$expdata),
#            breaks = 1e6,
#            xlim = c(0, 50))
#  
#  hist(as.matrix(seu@assays$RNA$counts), breaks = 1e6, xlim =c(0, 50))
#  
#  trimmed_expdata <- assays(sce)$expdata[assays(sce)$expdata < 10]
#  hist(as.matrix(trimmed_expdata))
#  abline(v=1, col = "blue")
#  
#  trimmed_expdata <- seu@assays$RNA$counts[seu@assays$RNA$counts < 10]
#  hist(as.matrix(trimmed_expdata))
#  abline(v=1, col = "blue")
#cutoff =1
 
```

### Binarize
```{r eval=FALSE}
#sce    <- binarize_exp(sce, fix_cutoff = TRUE, binarize_cutoff = 1, ncores = 64)
#Mole21a.sce   <- binarize_exp(Mole21a.sce, fix_cutoff = TRUE, binarize_cutoff = 1, ncores = 64)
#sce <- binarize_exp(sce, ncores = 64)
#Mole21a.sce   <- binarize_exp(Mole21a.sce, ncores = 64)
```

### CHECKPOINT
##### **with how long binerizing takes you may want to choose to save objects for future use.
```{r eval=FALSE}
 # saveRDS(sce   , "~/R Packages/mini_data/Binerized/reference.rds")
 # saveRDS(Mole21a.sce  , "~/R Packages/mini_data/Binerized/Mole21a.rds")
 # 
 # sce    <- readRDS("~/R Packages/mini_data/Binerized/reference.rds")
Mole21a.sce   <- readRDS("/mainfs/ddnb/PathPinpointR/package/PathPinpointR/data/binarized_blastocyst_Mole21a_sce.rds")
```

### fit logistic regression and find the switching pseudo-time point for each gene
```{r eval=FALSE}
#sce <- find_switch_logistic_fastglm(sce, downsample = FALSE, show_warning = FALSE)
```

#### **This is another time consuming process, may want to choose to save objects for future use.**
```{r eval=FALSE}
## saveRDS(sce   , "~/R Packages/mini_data/Binerized/reference_glm.rds")
sce    <- readRDS("/mainfs/ddnb/PathPinpointR/package/PathPinpointR/data/switches_gastglm_blastocyst_reference_sce.rds")
```

### Filter to only include Switching Genes
```{r eval=FALSE}
switchingGenes <- filter_switchgenes(sce, allgenes = TRUE,r2cutoff = 0.2)
```

##### View all of the switching genes
```{r eval=FALSE}
plot_timeline_ggplot(switchingGenes, timedata = colData(sce)$Pseudotime, txtsize = 3)
```


# Using PPR

##### View the selected switching genes
```{r eval=FALSE}
ppr_timeline_plot(switchingGenes)
```

### Reduce the binary counts matricies of the query data to only include the selection of evenly distributed genes from the refernence.
```{r eval=FALSE}
Mole21a_reduced      <- ppr_filter_gene_expression_for_switching_genes(Mole21a.sce@assays@data@listData$binary   ,switchingGenes )
reference_reduced    <- ppr_filter_gene_expression_for_switching_genes(sce@assays@data@listData$binary    , switchingGenes)
```

### Produce an estimate for the position on trajectory of each gene in each cell of a sample.
```{r eval=FALSE}
Mole21a.ppr   <- PathPinpointR::ppr_predict_position(Mole21a_reduced  , switchingGenes)
reference.ppr    <- ppr_predict_position(reference_reduced   , switchingGenes)
```

### Accuracy
#### *As our samples are subsets of the reference dataset we can calculate the accuracy of GSS*
```{r eval=FALSE}
ppr_accuracy_test(Mole21a.ppr, sce)
ppr_accuracy_test(reference.ppr, sce)
```

## Plotting

### Plot the predicted position of each sample:
#### *Optional: include the switching point of some genes of interest:*
```{r eval=FALSE}
ppr_output_plot(Mole21a.ppr, col = "red", overlay=FALSE, label = "Mole21a")
#ppr_output_plot(ANOTHER!.ppr, col = "green", overlay=TRUE, label = "ANOTHER!")
```




#### Plot an indervidual cell.
```{r eval=FALSE}
ppr_cell_plot(Mole21a.ppr, cell_idx = 1)
```

```{r eval=FALSE}
ppr_timeline_plot(switchingGenes, genomic_expression_traces = TRUE, reduced_binary_counts_matrix = Mole21a_reduced, cell_id = 1)
```

### Precision
##### Estimate the precision of PPR by running accuracy_test at a range of values
###### BUG! 
```{r eval=FALSE}
ppr_precision(sce)
```

### Investigate the predicted position of indervidual cells:
```{r eval=FALSE}
#
plot(Mole21a_accuracy$true_position_of_cells_timeIDX, Mole21a_accuracy$inaccuracy,
     xlab = "True Position", ylab = "Inaccuracy", main = "Inaccuracy by True Positions")

#
boxplot(Mole21a_accuracy$inaccuracy ~ Mole21a_accuracy$true_position_of_cells_timeIDX,
        xlab = "True Position", ylab = "Inaccuracy", main = "Boxplots of Inaccuracy by True Positions")
true_position_bin <- cut(Mole21a_accuracy$true_position_of_cells_timeIDX,
                             breaks = c(0,5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80.85,90,95,100))
boxplot(Mole21a_accuracy$inaccuracy ~ true_position_bin,
        xlab = "True Position", ylab = "Inaccuracy", main = "Boxplots of Inaccuracy by True Positions")

#
plot(Mole21a_accuracy$true_position_of_cells_timeIDX,Mole21a_accuracy$predicted_position_of_cells_timeIDX,
     xlab = "True Position", ylab = "Predicted Position", main = "Predicted Positions by True Positions")
segments(0,0,100,100, lwd=2, col ="green")
segments(0,10,100,110, lwd=2, col ="blue")
segments(0,-10,100,90, lwd=2, col ="blue")
segments(0,40,100,140, lwd=2, col ="red")
segments(0,-40,100,60, lwd=2, col ="red")

#
boxplot(Mole21a_accuracy$predicted_position_of_cells_timeIDX ~ Mole21a_accuracy$true_position_of_cells_timeIDX,
        xlab = "True Position", ylab = "Predicted Position", main = "Boxplots of Predicted Positions by True Positions")
segments(0,0,100,100, lwd=2, col ="green")
segments(0,10,100,110, lwd=2, col ="blue")
segments(0,-10,100,90, lwd=2, col ="blue")
segments(0,40,100,140, lwd=2, col ="red")
segments(0,-40,100,60, lwd=2, col ="red")
```


